{"version":3,"file":"148.c93ab213da47a1c69bbc.js","mappings":"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","sources":["webpack://mytonwallet/./node_modules/@capacitor-community/bluetooth-le/dist/esm/web.js","webpack://mytonwallet/./node_modules/@capacitor-community/bluetooth-le/dist/esm/timeout.js"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\nimport { hexStringToDataView, mapToObject, webUUIDToString } from './conversion';\nimport { runWithTimeout } from './timeout';\nexport class BluetoothLeWeb extends WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.deviceMap = new Map();\n        this.discoveredDevices = new Map();\n        this.scan = null;\n        this.DEFAULT_CONNECTION_TIMEOUT = 10000;\n        this.onAdvertisementReceivedCallback = this.onAdvertisementReceived.bind(this);\n        this.onDisconnectedCallback = this.onDisconnected.bind(this);\n        this.onCharacteristicValueChangedCallback = this.onCharacteristicValueChanged.bind(this);\n    }\n    async initialize() {\n        if (typeof navigator === 'undefined' || !navigator.bluetooth) {\n            throw this.unavailable('Web Bluetooth API not available in this browser.');\n        }\n        const isAvailable = await navigator.bluetooth.getAvailability();\n        if (!isAvailable) {\n            throw this.unavailable('No Bluetooth radio available.');\n        }\n    }\n    async isEnabled() {\n        // not available on web\n        return { value: true };\n    }\n    async requestEnable() {\n        throw this.unavailable('requestEnable is not available on web.');\n    }\n    async enable() {\n        throw this.unavailable('enable is not available on web.');\n    }\n    async disable() {\n        throw this.unavailable('disable is not available on web.');\n    }\n    async startEnabledNotifications() {\n        // not available on web\n    }\n    async stopEnabledNotifications() {\n        // not available on web\n    }\n    async isLocationEnabled() {\n        throw this.unavailable('isLocationEnabled is not available on web.');\n    }\n    async openLocationSettings() {\n        throw this.unavailable('openLocationSettings is not available on web.');\n    }\n    async openBluetoothSettings() {\n        throw this.unavailable('openBluetoothSettings is not available on web.');\n    }\n    async openAppSettings() {\n        throw this.unavailable('openAppSettings is not available on web.');\n    }\n    async setDisplayStrings() {\n        // not available on web\n    }\n    async requestDevice(options) {\n        const filters = this.getFilters(options);\n        const device = await navigator.bluetooth.requestDevice({\n            filters: filters.length ? filters : undefined,\n            optionalServices: options === null || options === void 0 ? void 0 : options.optionalServices,\n            acceptAllDevices: filters.length === 0,\n        });\n        this.deviceMap.set(device.id, device);\n        const bleDevice = this.getBleDevice(device);\n        return bleDevice;\n    }\n    async requestLEScan(options) {\n        this.requestBleDeviceOptions = options;\n        const filters = this.getFilters(options);\n        await this.stopLEScan();\n        this.discoveredDevices = new Map();\n        navigator.bluetooth.removeEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n        navigator.bluetooth.addEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n        this.scan = await navigator.bluetooth.requestLEScan({\n            filters: filters.length ? filters : undefined,\n            acceptAllAdvertisements: filters.length === 0,\n            keepRepeatedDevices: options === null || options === void 0 ? void 0 : options.allowDuplicates,\n        });\n    }\n    onAdvertisementReceived(event) {\n        var _a, _b;\n        const deviceId = event.device.id;\n        this.deviceMap.set(deviceId, event.device);\n        const isNew = !this.discoveredDevices.has(deviceId);\n        if (isNew || ((_a = this.requestBleDeviceOptions) === null || _a === void 0 ? void 0 : _a.allowDuplicates)) {\n            this.discoveredDevices.set(deviceId, true);\n            const device = this.getBleDevice(event.device);\n            const result = {\n                device,\n                localName: device.name,\n                rssi: event.rssi,\n                txPower: event.txPower,\n                manufacturerData: mapToObject(event.manufacturerData),\n                serviceData: mapToObject(event.serviceData),\n                uuids: (_b = event.uuids) === null || _b === void 0 ? void 0 : _b.map(webUUIDToString),\n            };\n            this.notifyListeners('onScanResult', result);\n        }\n    }\n    async stopLEScan() {\n        var _a;\n        if ((_a = this.scan) === null || _a === void 0 ? void 0 : _a.active) {\n            this.scan.stop();\n        }\n        this.scan = null;\n    }\n    async getDevices(options) {\n        const devices = await navigator.bluetooth.getDevices();\n        const bleDevices = devices\n            .filter((device) => options.deviceIds.includes(device.id))\n            .map((device) => {\n            this.deviceMap.set(device.id, device);\n            const bleDevice = this.getBleDevice(device);\n            return bleDevice;\n        });\n        return { devices: bleDevices };\n    }\n    async getConnectedDevices(_options) {\n        const devices = await navigator.bluetooth.getDevices();\n        const bleDevices = devices\n            .filter((device) => {\n            var _a;\n            return (_a = device.gatt) === null || _a === void 0 ? void 0 : _a.connected;\n        })\n            .map((device) => {\n            this.deviceMap.set(device.id, device);\n            const bleDevice = this.getBleDevice(device);\n            return bleDevice;\n        });\n        return { devices: bleDevices };\n    }\n    async connect(options) {\n        var _a, _b;\n        const device = this.getDeviceFromMap(options.deviceId);\n        device.removeEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n        device.addEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n        const timeoutError = Symbol();\n        if (device.gatt === undefined) {\n            throw new Error('No gatt server available.');\n        }\n        try {\n            const timeout = (_a = options.timeout) !== null && _a !== void 0 ? _a : this.DEFAULT_CONNECTION_TIMEOUT;\n            await runWithTimeout(device.gatt.connect(), timeout, timeoutError);\n        }\n        catch (error) {\n            // cancel pending connect call, does not work yet in chromium because of a bug:\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=684073\n            await ((_b = device.gatt) === null || _b === void 0 ? void 0 : _b.disconnect());\n            if (error === timeoutError) {\n                throw new Error('Connection timeout');\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    onDisconnected(event) {\n        const deviceId = event.target.id;\n        const key = `disconnected|${deviceId}`;\n        this.notifyListeners(key, null);\n    }\n    async createBond(_options) {\n        throw this.unavailable('createBond is not available on web.');\n    }\n    async isBonded(_options) {\n        throw this.unavailable('isBonded is not available on web.');\n    }\n    async disconnect(options) {\n        var _a;\n        (_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    async getServices(options) {\n        var _a, _b;\n        const services = (_b = (await ((_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.getPrimaryServices()))) !== null && _b !== void 0 ? _b : [];\n        const bleServices = [];\n        for (const service of services) {\n            const characteristics = await service.getCharacteristics();\n            const bleCharacteristics = [];\n            for (const characteristic of characteristics) {\n                bleCharacteristics.push({\n                    uuid: characteristic.uuid,\n                    properties: this.getProperties(characteristic),\n                    descriptors: await this.getDescriptors(characteristic),\n                });\n            }\n            bleServices.push({ uuid: service.uuid, characteristics: bleCharacteristics });\n        }\n        return { services: bleServices };\n    }\n    async getDescriptors(characteristic) {\n        try {\n            const descriptors = await characteristic.getDescriptors();\n            return descriptors.map((descriptor) => ({\n                uuid: descriptor.uuid,\n            }));\n        }\n        catch (_a) {\n            return [];\n        }\n    }\n    getProperties(characteristic) {\n        return {\n            broadcast: characteristic.properties.broadcast,\n            read: characteristic.properties.read,\n            writeWithoutResponse: characteristic.properties.writeWithoutResponse,\n            write: characteristic.properties.write,\n            notify: characteristic.properties.notify,\n            indicate: characteristic.properties.indicate,\n            authenticatedSignedWrites: characteristic.properties.authenticatedSignedWrites,\n            reliableWrite: characteristic.properties.reliableWrite,\n            writableAuxiliaries: characteristic.properties.writableAuxiliaries,\n        };\n    }\n    async getCharacteristic(options) {\n        var _a;\n        const service = await ((_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.getPrimaryService(options === null || options === void 0 ? void 0 : options.service));\n        return service === null || service === void 0 ? void 0 : service.getCharacteristic(options === null || options === void 0 ? void 0 : options.characteristic);\n    }\n    async getDescriptor(options) {\n        const characteristic = await this.getCharacteristic(options);\n        return characteristic === null || characteristic === void 0 ? void 0 : characteristic.getDescriptor(options === null || options === void 0 ? void 0 : options.descriptor);\n    }\n    async discoverServices(_options) {\n        throw this.unavailable('discoverServices is not available on web.');\n    }\n    async getMtu(_options) {\n        throw this.unavailable('getMtu is not available on web.');\n    }\n    async requestConnectionPriority(_options) {\n        throw this.unavailable('requestConnectionPriority is not available on web.');\n    }\n    async readRssi(_options) {\n        throw this.unavailable('readRssi is not available on web.');\n    }\n    async read(options) {\n        const characteristic = await this.getCharacteristic(options);\n        const value = await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.readValue());\n        return { value };\n    }\n    async write(options) {\n        const characteristic = await this.getCharacteristic(options);\n        let dataView;\n        if (typeof options.value === 'string') {\n            dataView = hexStringToDataView(options.value);\n        }\n        else {\n            dataView = options.value;\n        }\n        await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.writeValueWithResponse(dataView));\n    }\n    async writeWithoutResponse(options) {\n        const characteristic = await this.getCharacteristic(options);\n        let dataView;\n        if (typeof options.value === 'string') {\n            dataView = hexStringToDataView(options.value);\n        }\n        else {\n            dataView = options.value;\n        }\n        await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.writeValueWithoutResponse(dataView));\n    }\n    async readDescriptor(options) {\n        const descriptor = await this.getDescriptor(options);\n        const value = await (descriptor === null || descriptor === void 0 ? void 0 : descriptor.readValue());\n        return { value };\n    }\n    async writeDescriptor(options) {\n        const descriptor = await this.getDescriptor(options);\n        let dataView;\n        if (typeof options.value === 'string') {\n            dataView = hexStringToDataView(options.value);\n        }\n        else {\n            dataView = options.value;\n        }\n        await (descriptor === null || descriptor === void 0 ? void 0 : descriptor.writeValue(dataView));\n    }\n    async startNotifications(options) {\n        const characteristic = await this.getCharacteristic(options);\n        characteristic === null || characteristic === void 0 ? void 0 : characteristic.removeEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n        characteristic === null || characteristic === void 0 ? void 0 : characteristic.addEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n        await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.startNotifications());\n    }\n    onCharacteristicValueChanged(event) {\n        var _a, _b;\n        const characteristic = event.target;\n        const key = `notification|${(_a = characteristic.service) === null || _a === void 0 ? void 0 : _a.device.id}|${(_b = characteristic.service) === null || _b === void 0 ? void 0 : _b.uuid}|${characteristic.uuid}`;\n        this.notifyListeners(key, {\n            value: characteristic.value,\n        });\n    }\n    async stopNotifications(options) {\n        const characteristic = await this.getCharacteristic(options);\n        await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.stopNotifications());\n    }\n    getFilters(options) {\n        var _a;\n        const filters = [];\n        for (const service of (_a = options === null || options === void 0 ? void 0 : options.services) !== null && _a !== void 0 ? _a : []) {\n            filters.push({\n                services: [service],\n                name: options === null || options === void 0 ? void 0 : options.name,\n                namePrefix: options === null || options === void 0 ? void 0 : options.namePrefix,\n            });\n        }\n        if (((options === null || options === void 0 ? void 0 : options.name) || (options === null || options === void 0 ? void 0 : options.namePrefix)) && filters.length === 0) {\n            filters.push({\n                name: options.name,\n                namePrefix: options.namePrefix,\n            });\n        }\n        return filters;\n    }\n    getDeviceFromMap(deviceId) {\n        const device = this.deviceMap.get(deviceId);\n        if (device === undefined) {\n            throw new Error('Device not found. Call \"requestDevice\", \"requestLEScan\" or \"getDevices\" first.');\n        }\n        return device;\n    }\n    getBleDevice(device) {\n        var _a;\n        const bleDevice = {\n            deviceId: device.id,\n            // use undefined instead of null if name is not available\n            name: (_a = device.name) !== null && _a !== void 0 ? _a : undefined,\n        };\n        return bleDevice;\n    }\n}\n//# sourceMappingURL=web.js.map","export async function runWithTimeout(promise, time, exception) {\n    let timer;\n    return Promise.race([\n        promise,\n        new Promise((_, reject) => {\n            timer = setTimeout(() => reject(exception), time);\n        }),\n    ]).finally(() => clearTimeout(timer));\n}\n//# sourceMappingURL=timeout.js.map"],"names":["BluetoothLeWeb","constructor","super","arguments","this","deviceMap","Map","discoveredDevices","scan","DEFAULT_CONNECTION_TIMEOUT","onAdvertisementReceivedCallback","onAdvertisementReceived","bind","onDisconnectedCallback","onDisconnected","onCharacteristicValueChangedCallback","onCharacteristicValueChanged","initialize","navigator","bluetooth","unavailable","getAvailability","isEnabled","value","requestEnable","enable","disable","startEnabledNotifications","stopEnabledNotifications","isLocationEnabled","openLocationSettings","openBluetoothSettings","openAppSettings","setDisplayStrings","requestDevice","options","filters","getFilters","device","length","undefined","optionalServices","acceptAllDevices","set","id","getBleDevice","requestLEScan","requestBleDeviceOptions","stopLEScan","removeEventListener","addEventListener","acceptAllAdvertisements","keepRepeatedDevices","allowDuplicates","event","_a","_b","deviceId","has","result","localName","name","rssi","txPower","manufacturerData","serviceData","uuids","map","notifyListeners","active","stop","getDevices","devices","filter","deviceIds","includes","getConnectedDevices","_options","gatt","connected","connect","getDeviceFromMap","timeoutError","Symbol","Error","timeout","async","promise","time","exception","timer","Promise","race","_","reject","setTimeout","finally","clearTimeout","runWithTimeout","error","disconnect","key","target","createBond","isBonded","getServices","services","getPrimaryServices","bleServices","service","characteristics","getCharacteristics","bleCharacteristics","characteristic","push","uuid","properties","getProperties","descriptors","getDescriptors","descriptor","broadcast","read","writeWithoutResponse","write","notify","indicate","authenticatedSignedWrites","reliableWrite","writableAuxiliaries","getCharacteristic","getPrimaryService","getDescriptor","discoverServices","getMtu","requestConnectionPriority","readRssi","readValue","dataView","writeValueWithResponse","writeValueWithoutResponse","readDescriptor","writeDescriptor","writeValue","startNotifications","stopNotifications","namePrefix","get"],"sourceRoot":""}