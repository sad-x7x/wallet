{"version":3,"file":"642.4019c935ee6610070ce7.js","mappings":"waAOA,MCDaA,EAAcC,GACpBA,GAAUA,EAAMC,UAEjBD,EAAMC,QAAQC,SAAS,qBAAuBF,EAAMC,QAAQC,SAAS,cAChE,IAAIC,EAAAA,mBAHwBH,EAS1BI,EAAgBC,IAE3B,MAAMA,QAAAA,EAAK,IAAIC,KAAO,E,+aCyBxB,MAAMC,EAAW,cAKXC,EAA4D,CAChEC,iBAAkB,IAClBC,uBAAwB,KAIpBC,EAA+D,CAAC,EAsBhEC,EAAwD,CAAC,EAGzDC,EAA0C,CAG9CC,WAAY,IAEZC,mBAAoB,GAGhBC,EAAyBA,CAACC,EAAkBC,KAChD,MAAMC,EAAkBP,EAAgBK,GACpCE,GAAmBA,EAAgBC,qBACrCC,EAAAA,EAAAA,OAAM,CAAEC,KAAMf,EAAUN,QAAS,6BAA8BiB,YAC/DK,aAAaJ,EAAgBC,mBAC/B,EAGF,IAAII,EC7EAC,EDoFW,MAAMC,UAAqBC,EAAAA,GAYxC,aAAOC,CACLC,GAEA,IAAIC,GAAwB,EAwB5B,OAvBe,IAAIC,EAAAA,YAAYxB,GACxBc,MAAM,6BAERW,EAAAA,GAAUC,qBAAoBC,EAAAA,EAAAA,OAA4BC,MAAKC,UAClE,IAAIN,EAAJ,CACA,IAAK,MAAMO,KAAMC,EACfT,EAASU,KAAK,CACZjB,KAAM,MACNkB,OAAQH,UAGNL,EAAAA,GAAUS,aACXT,EAAAA,GAAUU,cAAc,CAC3BC,UAAUT,EAAAA,EAAAA,QACRU,IACEd,GACJD,EAASU,KAAK,CACZjB,KAAM,MACNkB,OAAQI,EAAOJ,QACf,GAfoB,CAgBtB,IAGG,CACLK,YAAaT,UACXN,GAAe,QACTE,EAAAA,GAAUS,YAAY,EAGlC,CAWA,iBAAaK,CACXC,EACAC,EACA9B,GAEuB,IADvB,cAAE+B,GAAkDC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAExD,OAAOJ,EAAKC,GAAY,EAAMC,EAAW9B,EAAS,CAAE+B,iBACtD,CAyEAI,WAAAA,CACEb,EACAc,EACAC,EACAC,EACAC,GAEA,IAAAC,EAAA,IADA,QAAExC,EAAO,cAAE+B,GAA0EC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAEzFS,MAAM,CAAEzC,UAAS0C,QAASrD,IAAWmD,EAAAG,KAAAC,EAAA,sBAAAA,EAAA,2BAlDvCA,EAAA,yBAC0D,MAAIA,EAAA,kBAAAA,EAAA,oBAIhD,GAAIA,EAAA,eAER,IAEVA,EAAA,gCAAAA,EAAA,2BAGqB,GAAIA,EAAA,kDAAAA,EAAA,qDAAAA,EAAA,6BAQzBA,EAAA,qCAAAA,EAAA,4BAAAA,EAAA,kCA6CAA,EAAA,iBAYW,SACT7D,GAEoB,IADpB,eAAE8D,GAA6Cb,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAE/CQ,EAAKM,qBACFtC,EAAauC,iBAAiBP,EAAKQ,GAAIR,EAAKS,cAEnD,MAAMC,EAASV,EAAKU,OAAOC,mBAAmB,CAC5CC,SAAU,aAKZ,OAHAF,EAAO/C,MAAM,sBAAuB,CAAE0C,mBACtCK,EAAOG,SAAS,QAAQlD,MAAM,MAAMpB,EAAQuE,SAAS,UAE9Cd,EAAKe,oBAAmB,KACtBC,EAAAA,EAAAA,IAILC,EAAAA,EAAAA,GACEjB,EAAKF,iBAAiBoB,MAAMC,IAASC,EAAAA,EAAAA,GAAYD,EAAM,CAAE3D,QAASkD,EAAOW,kBACzEC,EAAAA,EAAAA,UAAStB,EAAKuB,MAAOhF,EAASyD,EAAKwB,QAAS,CAC1ChE,QAASkD,EAAOW,gBAElBH,KACAb,GAAiBoB,EAAAA,EAAAA,GAAQpB,EAAgBL,EAAKT,gBAAiBmC,EAAAA,EAAAA,MAC/DA,EAAAA,EAAAA,IAAKP,IACHT,EAAOG,SAAS,QAAQlD,MAAM,MAAMwD,EAAKL,SAAS,SAAS,KAE7Da,EAAAA,EAAAA,IAAWjD,UAET,GAAIpC,aAAiBsF,EAAAA,EAYnB,MAXAlB,EAAO/C,MACL,+FACA,CACE0C,iBACAwB,eAAgB7B,EAAK8B,8BAKnB9B,EAAK+B,0BAEL,IAAIC,EAAAA,8BAA8B,mCAG1CtB,EAAOG,SAAS,aAAalD,MAAM,8BAA+B,CAAErB,UAEhE0D,EAAKiC,0BAGDjE,EAAauC,iBAAiBP,EAAKQ,GAAIR,EAAKS,cAGpD,MAAMyB,EAAc7F,EAAWC,GAK/B,MAJAoE,EAAO/C,MAAM,iEAAkE,CAC7EuE,gBAGIA,CAAW,KAEnBC,EAAAA,EAAAA,IAAS,KACPzB,EAAO/C,MAAM,mCAAoC,CAC/CmE,sBAAuB9B,EAAK8B,wBAE9B9B,EAAKoC,4BAA4B,OAK3C,IA+FAhC,EAAA,cAYQ1B,UACN,MAAM2D,GAAgBC,EAAAA,EAAAA,KACtBnC,KAAK2B,sBAAsBS,KAAKF,GAEhC,MAAM3B,EAASP,KAAKO,OAAOC,mBAAmB,CAAE0B,kBAChD3B,EAAO/C,MAAM,oBAAqB,CAChC6E,oBAAqBrC,KAAKN,wCAG5B,IACE,MAAM4C,EAAa,IAAIC,WAAWC,GAC5BC,EAAW,IAAIC,SAASJ,EAAWE,OAAQF,EAAWK,WAAYL,EAAWM,kBAC7EzE,EAAAA,GAAUiD,MACdpB,KAAKrB,OAAOvB,SACZO,EACAqC,KAAKP,mCAAmC0C,KACxCM,GAEFlC,EAAOG,SAAS,aAAalD,MAAM,MAAMgF,EAAO7B,SAAS,SAC3D,CAAE,MAAOxE,GAEP,MADAoE,EAAO/C,MAAM,2BAA4B,CAAErB,UACrC,IAAI0G,EAAAA,kCACR1G,aAAiBM,MAAQN,EAAMC,QAAU,GAAGD,IAEhD,KAlOA6D,KAAKK,GAAK1B,EAAOvB,SACjB4C,KAAKrB,OAASA,EACdqB,KAAKP,mCAAqCA,EAC1CO,KAAKN,sCAAwCA,EAC7CM,KAAKL,iBAAmBA,EACxBK,KAAKJ,YAAcA,EACnBI,KAAKZ,cAAgBA,EACrBY,KAAK2B,sBAAwB,GAE7BxE,EAAuB6C,KAAKK,IAE5BL,KAAKO,OAAO/C,MAAM,2CAA2CwC,KAAKK,KACpE,CAqFA,6BAAcuB,SAEN/D,EAAauC,iBAAiBJ,KAAKK,GAAIL,KAAKM,aACpD,CAKQ2B,0BAAAA,GACNjC,KAAK2B,sBAAwB,EAC/B,CAMA,cAAMmB,GACJ,IAAIC,QAAa5E,EAAAA,GAAU6E,OAAOhD,KAAKrB,OAAOvB,UA+C9C,OA9CA4C,KAAKO,OAAO/C,MAAM,oBAAqB,CAAEyF,iBAAkBF,UAErD/C,KAAKY,oBAAmBrC,UAC5B,IACEwE,QAAYlC,EAAAA,EAAAA,IACVC,EAAAA,EAAAA,GACEd,KAAKL,iBAAiBoB,MACpBmC,EAAAA,EAAAA,IAAKC,IAEH,GAAIA,aAAsB1G,MACxB,MAAM0G,EAGR,OAAOA,CAAU,KAEnBC,EAAAA,EAAAA,IAAOZ,GAAmC,IAAxBA,EAAOa,UAAU,MACnCH,EAAAA,EAAAA,IAAKV,GAAWA,EAAOa,UAAU,OAEnCC,EAAAA,EAAAA,IAAM,KAAMC,EAAAA,EAAAA,GAAKvD,KAAKoB,MAAMoC,EAAOD,KAAK,CAAC,EAAM,EAAG,EAAG,EAAG,QAAOxC,MAAK0C,EAAAA,EAAAA,OAG1E,CAAE,MAAOtH,GACP6D,KAAKO,OAAOG,SAAS,aAAalD,MAAM,4BAA6B,CAAEuF,cAEjElF,EAAauC,iBAAiBJ,KAAKK,GAAIL,KAAKM,cAElD,MAAMyB,EAAc7F,EAAWC,GAK/B,MAJA6D,KAAKO,OAAO/C,MAAM,gEAAiE,CACjFuE,gBAGIA,CACR,CAAE,QAEA/B,KAAKiC,4BACP,KAGFjC,KAAKO,OAAO/C,MAAM,0CAA2C,CAC3DuF,MACA1B,QAASrB,KAAKqB,UAEZ0B,EAAM,KACR/C,KAAKqB,QAAU0B,GAGV/C,KAAKqB,OACd,CAQA,+BAAMqC,CACJxG,GAEA,IAAIyG,EACJ,OAAQzG,GACN,IAAK,OAML,IAAK,WACHyG,EAA2BC,EAAAA,GAAmBC,6BAC9C,MALF,IAAK,WACHF,EAA2BC,EAAAA,GAAmBE,8BDrZbC,cC4ZnC5F,EAAAA,GAAUuF,0BAA0B1D,KAAKrB,OAAOvB,SAAUuG,GD5ZaI,EAAQC,MAAMzH,GC8ZzF,CAiDA,WAAM0H,GACJ,MAAM1D,EAASP,KAAKO,OAAOC,mBAAmB,CAAEC,SAAU,UAG1D,IAAIyD,EAFJ3D,EAAO/C,MAAM,oDAGb,MAAM2G,EAAoB,IAAIC,SAAeC,IAC3CH,EAAUG,CAAY,IAGxBlH,EAAuB6C,KAAKK,IAE5BL,KAAKzC,kBAAoB+G,YAAW,KAClC/D,EAAO/C,MAAM,2CACTwC,KAAKuE,YACP1G,EAAauC,iBAAiBJ,KAAKK,GAAIL,KAAKM,aAAcC,EAAOW,cAC9D8C,OAAM,SACNQ,QAAQN,GAEXA,GACF,GACCrG,EAAa4G,2BAIVL,QAAQM,KAAK,CAAC1E,KAAKG,qBAAuBiE,QAAQF,UAAWC,GACrE,EAcF5F,eAAeU,EACbC,EACAyF,EACAxF,EACA9B,GAEA,IADA,cAAE+B,GAAkDC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAExD,MAAMkB,EAAS,IAAIrC,EAAAA,YAAYxB,EAAUW,GACzC,IAAIsB,EAEAvB,EACAwH,EAEJ,GAJArE,EAAO/C,MAAM,WAAW0B,IAAc,CAAEyF,mBAId,iBAAfzF,EAAyB,CAElC,GADA9B,EAAW8B,EACPnC,EAAgBmC,GAMlB,OALAqB,EAAO/C,MAAM,gCACbL,EAAuB+B,GAGvBnC,EAAgBmC,GAAY2F,gBAAgBxH,GACrCN,EAAgBmC,GAGzBqB,EAAO/C,MAAM,0BAA0B0B,WEhiBpCX,iBAGL,SAFMuG,EAAAA,GAAYC,oBACMD,EAAAA,GAAYE,YAElC,MAAM,IAAIC,EAAAA,kBAAkB,GAAI,CAC9BC,MAAO,WAGb,CFyhBUC,GAGN,MAAM1G,QAAiBN,EAAAA,GAAUiH,WAAW,CAAClG,IAI7C,GAHAqB,EAAO/C,MAAM,SAASiB,EAAQa,+CAAgD,CAAEJ,gBAC/EP,GAAUF,GAENE,EAAQ,CAIX,MAAMG,SAAkBX,EAAAA,GAAUkH,YAAYnG,IAAagE,KAAK1E,GAAOA,EAAG2D,OAEpEmD,SAD0BnH,EAAAA,GAAUC,oBAAoBU,IACZyG,QAAQC,GAAMA,EAAEpI,WAAa8B,IAC/EqB,EAAO/C,MACL,iDACQ8H,EAAyBhG,gDACjC,CAAEJ,gBAEHP,GAAU2G,CACb,CAEA,IAAK3G,EAAQ,CAEX4B,EAAO/C,MAAM,4EAA6E,CACxF0B,aACAC,cAIF,UACQhB,EAAAA,GAAUsH,QAAQvG,GAAY,KAAM,IAAAwG,EAAAC,EAClB,QAAtBD,GAAAC,EAAAf,GAAUtE,oBAAY,IAAAoF,GAAtBA,EAAAE,KAAAD,EAA0B,GACzB,CACDrE,QAASnC,GAEb,CAAE,MAAO3C,GAEP,MADA+D,EAAO/C,MAAM,eAAehB,EAAEqJ,aACxBrJ,CACR,CACF,CAEA,IAAKmC,EACH,MAAM,IAAImH,EAAAA,cAEd,MAEEnH,EAASO,EACT9B,EAAW8B,EAAW9B,SAKxB,WAF+Be,EAAAA,GAAUC,qBAAoBC,EAAAA,EAAAA,QAEvC0H,MAAMvH,GAAOA,EAAGpB,WAAaA,IAAW,CAC5DmD,EAAO/C,MAAM,gDAAiD,CAAE2B,YAAWnC,mBAC3E,UACQmB,EAAAA,GAAUsH,QAAQrI,GAAU,KAAM,IAAA4I,EAAAC,EAChB,QAAtBD,GAAAC,EAAArB,GAAUtE,oBAAY,IAAA0F,GAAtBA,EAAAJ,KAAAK,EAA0B,GACzB,CACD3E,QAASnC,GAEb,CAAE,MAAOhD,GAGP,MAFAoE,EAAO/C,MAAM,gBAAiB,CAAErB,UAE1BD,EAAWC,EACnB,CACF,CAEAoE,EAAO/C,MAAM,iEAEb,IAAIsB,EAAyB,SAEvBX,EAAAA,GAAU+H,iBAAiB9I,GACjC0B,QAAkBX,EAAAA,GAAUkH,YAAYjI,GAExC,IAAI+I,EAvjBN,SAAuBxH,GACrB,IAAKA,IAAWA,EAAOyH,MAAO,OAC9B,MAAOC,GAAe1H,EAAOyH,MAC7B,IAAKC,EAAa,OAClB,MAAMC,GAAQC,EAAAA,EAAAA,IAAuBF,GACrC,OAAKC,GAGLxJ,EAAmB6B,EAAOvB,UAAYkJ,EAC/BA,QAJP,CAKF,CA6iBwCE,CAAc7H,GACpD,MAAM8H,EAAuC,GAE7C,IAAKN,EACH,IAAK,MAAME,KAAehI,EAAAA,EAAAA,MACxB,IACE,MAAMqI,EAAgB5H,EAASiH,MAAMvH,GAAOA,EAAG2D,OAASkE,IAExD,GADAF,GAAMI,EAAAA,EAAAA,IAAuBF,GACzBF,GAAOO,EAAe,CACxBD,EAAgBrE,QAAQsE,EAAcD,iBACtC9I,EAAuBwI,EAAIQ,YAC3B,KACF,CACF,CAAE,MAAOnK,GACP,CAKN,IAAK2J,EAEH,MADA5F,EAAO/C,MAAM,qBACP,IAAIoJ,EAAAA,eAAe,oBAAqB,sBAGhD,MAAM,YACJhH,EAAW,UAAEiH,EAAS,aAAEC,EAAY,WAAEC,GACpCZ,EAMJ,IAAKM,EAEH,MADAlG,EAAO/C,MAAM,6BACP,IAAIoJ,EAAAA,eAAe,oBAAqB,sBAGhD,IAAInH,EACAC,EAEAsH,EAEJ,IAAK,MAAMC,KAAKR,EACVQ,EAAE9E,OAAS0E,EACbpH,EAAqCwH,EAC5BA,EAAE9E,OAAS2E,EACpBpH,EAAwCuH,EAC/BA,EAAE9E,OAAS4E,IACpBC,EAA2BC,GAI/B,IAAKxH,EACH,MAAM,IAAImH,EAAAA,eAAe,iCAAkC,6BAG7D,IAAKI,EACH,MAAM,IAAIJ,EAAAA,eAAe,kCAAmC,6BAG9D,IAAKnH,EAAmCyH,WAAW9F,MACjD,MAAM,IAAIwF,EAAAA,eACR,0EACA,4BAIJ,IAAKI,EAAyBE,WAAWC,OACvC,MAAM,IAAIP,EAAAA,eAAe,uCAAwC,4BAGnE,GAAIlH,IACGA,EAAsCwH,WAAWE,qBACpD,MAAM,IAAIR,EAAAA,eACR,gFACA,4BAKN,MAAMS,QAAkBlJ,EAAAA,GAAU6E,OAAOrE,EAAOvB,UAChDmD,EAAO/C,MAAM,cAAc6J,KAG3B,MAAM1H,EF1rB6B2H,EACnClK,EACAmK,EACAC,EACAnK,IACuB,IAAIoK,EAAAA,GAAYC,IACxB,IAAIxJ,EAAAA,YARJ,cAQ0Bb,GAClCG,MAAM,uCAAwC,CACnDmK,mBAAoBH,EAAerF,OAGhChE,EAAAA,GAAUyJ,mBACbxK,EACAmK,EACAC,EAAerF,MACd0F,IACC,MAAMvF,EAAa,IAAIC,WAAWsF,EAAMrF,QAClCA,EAASgB,EAAOD,KAAKjB,GAC3BoF,EAAEhJ,KAAK8D,EAAO,IAIX,KACArE,EAAAA,GAAU2J,0BAA0B,KEmqBlBR,CAAsBlK,EAC7CO,EACAqJ,EACA3J,GAAS0D,MACTS,EAAAA,EAAAA,IAAYhF,IAGV,MAAMuL,EAAMC,OAAOxL,GACnB,OAAOuL,EAAI1L,SAAS,yBAChB4L,EAAAA,EAAAA,IAAG,IAAIC,EAAAA,cAAcH,KACrBI,EAAAA,EAAAA,IAAW,IAAM3L,GAAE,KAEzB+E,EAAAA,EAAAA,IAAKsG,IACCA,aAAiBK,EAAAA,gBACrB1K,EAAAA,EAAAA,OAAM,CAAEC,KAAM,YAAarB,QAAS,MAAMyL,EAAMlH,SAAS,SAAUtD,WAAU,KAI/E+K,EAAAA,EAAAA,MAIIC,EAAQ1I,EAAiB2I,YAE/B1D,EAAY,IAAI/G,EACdc,EACAc,EACAC,EACAC,EACAC,EACA,CACEvC,UACA+B,kBAGJmB,EAAO/C,MAAM,4BASboH,EAAUtE,aAAgBnE,IAAkB,IAAAoM,EAAAC,EAC1C5D,EAAUL,aAAc,EACxBK,EAAU9C,oBAAqB,EAC/BuG,EAAMrJ,cAGN7B,EAAuByH,EAAUvE,WAC1BtD,EAAgB6H,EAAUvE,IACjCE,EAAO/C,MACL,iEAAiEoH,EAAUvE,2DAC5BlE,KAC/C,CAAEsM,OAAQtM,IAEZyI,EAAU8D,KAAK,aAAcvM,GACD,QAA5BoM,GAAAC,EAAA5D,GAAU+D,0BAAkB,IAAAJ,GAA5BA,EAAA3C,KAAA4C,EAAgC,EAIlCzL,EAAgB6H,EAAUvE,IAAMuE,EAChC,MAAMgE,EAAgBC,KAAKC,MAO3B,UACQlE,EAAU9B,UAClB,CAAE,QACA,MAAMiG,EAAeF,KAAKC,MAEtBnM,GAKEoM,EAAeH,EAAgBjM,EAAmBC,iBACpD+H,GAAiB,EACR/E,EAAYS,KAAO2I,EAAAA,GAAcC,OAC1C1I,EAAO/C,MAAM,+CACbmH,GAAiB,GAGfA,IACFpE,EAAO/C,MAAM,4DACPK,EAAauC,iBAAiBwE,EAAUvE,GAAIuE,EAAUtE,oBAvtBrD4I,EAwtBKvM,EAAmBE,uBAxtBG,IAAIuH,SAAS+E,GAAY7E,WAAW6E,EAASD,QA2tBjFvE,GAAiB,CAErB,CA7tBauE,MA+tBb,OAAIvE,GACFpE,EAAO/C,MAAM,gBACNyB,EAAKN,GAAQ,EAAOQ,EAAW9B,IAGjCuH,CACT,CA1SA3E,EA1ZqBpC,EAAY,sBACF,KAAIoC,EADdpC,EAAY,QAGjB,KACZ,MAAM,IAAIpB,MAAM,kBAAkB,IACnCwD,EALkBpC,EAAY,oBAwELU,MAAO8B,EAC/BC,EACAjD,KACA,MAAMkD,EAAS,IAAIrC,EAAAA,YAAYxB,EAAUW,GACzCkD,EAAO/C,MAAM,+BAA+B6C,KAE5C,UACQlC,EAAAA,GAAUiL,WAAW/I,GAC3BC,SAAAA,GACF,CAAE,MAAOnE,GAEPoE,EACGG,SAAS,aACTlD,MAAM,iDAAkD,CAAErB,SAC/D,CACAoE,EAAO/C,MAAM,UAAU6C,iBAAkB,ICzK7C,IACIgJ,EACAC,EAFAC,EAAkC,GAItC,SAASC,IACP,QAAS5L,CACX,CAEA,SAAS6L,EAAwBC,GAC/B,QAAKH,EAAexD,MAAMvH,GAAOA,EAAGmL,aAAeD,EAAcC,eAMzDN,CACV,CAEA9K,eAAeqL,EAA0BF,GACvC,IAEE,IAAKD,EAAwBC,GAAgB,OAE7C,MAAMG,QAAqBhM,EAAaoB,KAAKyK,EAAc/K,QAE3D,IAAK8K,EAAwBC,GAAgB,OAE7C,MAAMI,EAAmB,CACvBnL,OAAQ+K,EAAc/K,OACtBkL,gBAEFR,EAAeS,EAEfD,EAAalB,mBAAqB,KAChCU,OAAe9J,EACXiK,MACFO,IACAC,IACF,EAGF1F,YAAW,KAAM,IAAA2F,EAEyDC,GAAxD,QAAZD,EAAAZ,SAAY,IAAAY,OAAA,EAAZA,EAActL,OAAOvB,YAAa0M,EAAiBnL,OAAOvB,UAC3C,QAAjB8M,EAAAZ,SAAiB,IAAAY,GAAjBA,EAAoBJ,GACpBC,KACSP,MAETH,OAAe9J,EACfwK,IACKC,IACP,GACC,IACL,CAAE,MAAO7N,GACPmI,YAAW,KACJsF,EAA0BF,EAAc,GAC5C,IACL,CACF,CAeA,SAASM,IACPpM,EAAwBC,EAAaE,OAAO,CAC1CW,KAAOyL,IACL,GACO,QADCA,EAAM1M,MAEN0M,EAAMxL,OAAQ,CAChB,IAAKwL,EAAMxL,OAAOyL,KAAM,OACxB,GAAIb,EAAexD,MAAMvH,IAAE,IAAA6L,EAAA,OAAK7L,EAAGG,OAAOvB,YAAyB,QAAjBiN,EAAKF,EAAMxL,cAAM,IAAA0L,OAAA,EAAZA,EAAcjN,SAAS,IAAE,OAChF,MAAMsM,EAAgB,CAAEC,YAAYxH,EAAAA,EAAAA,KAAQxD,OAAQwL,EAAMxL,QAC1D4K,EAAenH,KAAKsH,GACfE,EAA0BF,EACjC,CAEJ,EAEFvN,MAAOA,KACL4N,GAAM,EAERO,SAAUA,KACRP,GAAM,GAGZ,CAEA,SAASA,IAAO,IAAAQ,EACdhB,EAAiB,GACI,QAArBgB,EAAA3M,SAAqB,IAAA2M,GAArBA,EAAuBvL,cACvBpB,OAAwB2B,CAC1B,CAeO,MAAMiL,EAAe,CAC1BC,YAzDFlM,iBACE,IAAKmM,EAAAA,IAAc,OAAO,EAE1B,UACQvM,EAAAA,GAAU4G,WAAW,CACzB4F,yBAAyB,UAErBxM,EAAAA,GAAUyM,eAClB,CAAE,MAAOzO,GAAoB,CAE7B,OAAOgC,EAAAA,GAAU6G,WACnB,EA+CES,QAfF,WACE,OAAO,IAAIrB,SAASF,IAClBoF,EAAoBpF,EAChBmF,EACFC,EAAkBD,GAIhBG,KACJQ,GAAO,GAEX,EAKED,O","sources":["webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/monitorCharacteristic.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/remapErrors.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/BleTransport.ts","webpack://mytonwallet/./src/util/ledger/bleConnector.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/awaitsBleOn.ts"],"sourcesContent":["import { BleClient } from '@capacitor-community/bluetooth-le';\nimport type { TraceContext } from '@ledgerhq/logs';\nimport { LocalTracer } from '@ledgerhq/logs';\nimport { Observable } from 'rxjs';\n\nimport type { Characteristic } from './types';\n\nconst LOG_TYPE = 'ble-verbose';\n\nexport const monitorCharacteristic = (\n  deviceId: string,\n  serviceId: string,\n  characteristic: Characteristic,\n  context?: TraceContext,\n): Observable<Buffer> => new Observable((o) => {\n  const tracer = new LocalTracer(LOG_TYPE, context);\n  tracer.trace('Start monitoring BLE characteristics', {\n    characteristicUuid: characteristic.uuid,\n  });\n\n  void BleClient.startNotifications(\n    deviceId,\n    serviceId,\n    characteristic.uuid,\n    (value) => {\n      const uint8Array = new Uint8Array(value.buffer);\n      const buffer = Buffer.from(uint8Array);\n      o.next(buffer);\n    },\n  );\n\n  return () => {\n    void BleClient.stopEnabledNotifications();\n  };\n});\n","import {\n  DisconnectedDevice,\n} from '@ledgerhq/errors';\n\nexport type IOBleErrorRemap = Error | null | undefined;\n\nexport const remapError = (error: IOBleErrorRemap): IOBleErrorRemap => {\n  if (!error || !error.message) return error;\n\n  if (error.message.includes('was disconnected') || error.message.includes('not found')) {\n    return new DisconnectedDevice();\n  }\n\n  return error;\n};\n\nexport const rethrowError = (e: Error | null | undefined): never => {\n  // throw remapError(e);\n  throw e ?? new Error();\n};\n\nexport const decoratePromiseErrors = <A>(promise: Promise<A>): Promise<A> => promise.catch(rethrowError);\n","import type { BleService } from '@capacitor-community/bluetooth-le';\nimport { BleClient, ConnectionPriority } from '@capacitor-community/bluetooth-le';\nimport type { BluetoothInfos, DeviceModel } from '@ledgerhq/devices';\nimport { DeviceModelId, getBluetoothServiceUuids, getInfosForServiceUuid } from '@ledgerhq/devices';\nimport { receiveAPDU } from '@ledgerhq/devices/lib/ble/receiveAPDU';\n// ---------------------------------------------------------------------------------------------\n// Since this is a react-native library and metro bundler does not support\n// package exports yet (see: https://github.com/facebook/metro/issues/670)\n// we need to import the file directly from the lib folder.\n// Otherwise it would force the consumer of the lib to manually \"tell\" metro to resolve to /lib.\n//\n// TLDR: /!\\ Do not remove the /lib part in the import statements below (@ledgerhq/devices/lib) ! /!\\\n// See: https://github.com/LedgerHQ/ledger-live/pull/879\nimport { sendAPDU } from '@ledgerhq/devices/lib/ble/sendAPDU';\nimport type { HwTransportError } from '@ledgerhq/errors';\nimport {\n  CantOpenDevice,\n  DisconnectedDeviceDuringOperation,\n  PairingFailed,\n  TransportError,\n  TransportExchangeTimeoutError,\n} from '@ledgerhq/errors';\nimport type { Observer as TransportObserver, Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\nimport Transport from '@ledgerhq/hw-transport';\nimport type { TraceContext } from '@ledgerhq/logs';\nimport { LocalTracer, trace } from '@ledgerhq/logs';\nimport type { Observable, SchedulerLike } from 'rxjs';\nimport {\n  defer, firstValueFrom, from, merge, of, throwError, TimeoutError,\n} from 'rxjs';\nimport {\n  catchError, finalize, first, ignoreElements, map, share, tap, timeout,\n} from 'rxjs/operators';\nimport { v4 as uuid } from 'uuid';\nimport type { BleCharacteristic } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\n\nimport type { IOBleErrorRemap } from './remapErrors';\nimport type { Characteristic, Device, ReconnectionConfig } from './types';\n\nimport { awaitsBleOn } from './awaitsBleOn';\nimport { monitorCharacteristic } from './monitorCharacteristic';\nimport { decoratePromiseErrors, remapError } from './remapErrors';\n\nconst LOG_TYPE = 'ble-verbose';\n\n/**\n * This is potentially not needed anymore, to be checked if the bug is still happening.\n */\nconst reconnectionConfig: ReconnectionConfig | null | undefined = {\n  pairingThreshold: 1000,\n  delayAfterFirstPairing: 4000,\n};\n\n// Allows us to give more granulary error messages\nconst bluetoothInfoCache: { [deviceUuid: string]: BluetoothInfos } = {};\n\nfunction retrieveInfos(device: Device | null): BluetoothInfos | undefined {\n  if (!device || !device.uuids) return undefined;\n  const [serviceUUID] = device.uuids;\n  if (!serviceUUID) return undefined;\n  const infos = getInfosForServiceUuid(serviceUUID);\n  if (!infos) return undefined;\n\n  // If we retrieved information, update the cache\n  bluetoothInfoCache[device.deviceId] = infos;\n  return infos;\n}\n\n// eslint-disable-next-line no-promise-executor-return\nconst delay = (ms: number | undefined) => new Promise((success) => setTimeout(success, ms));\n\n/**\n * A cache of Bluetooth transport instances associated with device IDs.\n * Allows efficient storage and retrieval of previously initialized transports.\n * @type {Object.<string, BluetoothTransport>}\n */\nconst transportsCache: { [deviceId: string]: BleTransport } = {};\n\n// `connectOptions` is actually used by `react-native-ble-plx` even if comment above `ConnectionOptions` says it's not used\nconst connectOptions: Record<string, unknown> = {\n  // 156 bytes to max the iOS < 10 limit (158 bytes)\n  // (185 bytes for iOS >= 10)(up to 512 bytes for Android, but could be blocked at 23 bytes)\n  requestMTU: 156,\n  // Priority 1 = high.\n  connectionPriority: 1,\n};\n\nconst clearDisconnectTimeout = (deviceId: string, context?: TraceContext): void => {\n  const cachedTransport = transportsCache[deviceId];\n  if (cachedTransport && cachedTransport.disconnectTimeout) {\n    trace({ type: LOG_TYPE, message: 'Clearing queued disconnect', context });\n    clearTimeout(cachedTransport.disconnectTimeout);\n  }\n};\n\nlet currentDeviceService: string | undefined;\n\n/**\n * React Native bluetooth BLE implementation\n * @example\n * import BleTransport from \"@ledgerhq/react-native-hw-transport-ble\";\n */\nexport default class BleTransport extends Transport {\n  static disconnectTimeoutMs = 5000;\n\n  static list = (): Promise<void[]> => {\n    throw new Error('not implemented');\n  };\n\n  /**\n   * Scan for bluetooth Ledger devices\n   * @param observer Device is partial in order to avoid the live-common/this dep\n   * @returns TransportSubscription\n   */\n  static listen(\n    observer: TransportObserver<any, HwTransportError>,\n  ): TransportSubscription {\n    let unsubscribed: boolean = false;\n    const tracer = new LocalTracer(LOG_TYPE);\n    tracer.trace('Listening for devices ...');\n\n    void BleClient.getConnectedDevices(getBluetoothServiceUuids()).then(async (devices) => {\n      if (unsubscribed) return;\n      for (const it of devices) {\n        observer.next({\n          type: 'add',\n          device: it,\n        });\n      }\n      await BleClient.stopLEScan();\n      void BleClient.requestLEScan({\n        services: getBluetoothServiceUuids(),\n      }, (result) => {\n        if (unsubscribed) return;\n        observer.next({\n          type: 'add',\n          device: result.device,\n        });\n      });\n    });\n\n    return {\n      unsubscribe: async () => {\n        unsubscribed = true;\n        await BleClient.stopLEScan();\n      },\n    };\n  }\n\n  /**\n   * Opens a BLE transport\n   *\n   * @param {Device | string} deviceOrId\n   * @param timeoutMs Applied when trying to connect to a device\n   * @param context An optional context object for log/tracing strategy\n   * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\n   */\n  static async open(\n    deviceOrId: Device | string,\n    timeoutMs?: number,\n    context?: TraceContext,\n    { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\n  ): Promise<BleTransport> {\n    return open(deviceOrId, true, timeoutMs, context, { rxjsScheduler });\n  }\n\n  /**\n   * Exposes method from the ble-plx library to disconnect a device\n   *\n   * Disconnects from {@link Device} if it's connected or cancels pending connection.\n   * A \"disconnect\" event will normally be emitted by the ble-plx lib once the device is disconnected.\n   * Errors are logged but silenced.\n   */\n  static disconnectDevice = async (id: string,\n    onDisconnect?: (e?: Error) => void,\n    context?: TraceContext): Promise<void> => {\n    const tracer = new LocalTracer(LOG_TYPE, context);\n    tracer.trace(`Trying to disconnect device ${id}`);\n\n    try {\n      await BleClient.disconnect(id);\n      onDisconnect?.();\n    } catch (error) {\n      // Only log, ignore if disconnect did not work\n      tracer\n        .withType('ble-error')\n        .trace('Error while trying to cancel device connection', { error });\n    }\n    tracer.trace(`Device ${id} disconnected`);\n  };\n\n  device: Device;\n\n  deviceModel: DeviceModel;\n\n  // eslint-disable-next-line no-null/no-null\n  disconnectTimeout: null | ReturnType<typeof setTimeout> = null;\n\n  id: string;\n\n  isConnected = true;\n\n  mtuSize = 20;\n\n  // Observable emitting data received from the device via BLE\n  notifyObservable: Observable<Buffer | Error>;\n\n  notYetDisconnected = true;\n\n  writableWithResponseCharacteristic: Characteristic;\n\n  writableWithoutResponseCharacteristic: Characteristic | undefined;\n\n  rxjsScheduler?: SchedulerLike;\n\n  // Transaction ids of communication operations that are currently pending\n  currentTransactionIds: Array<string>;\n\n  onDisconnect: ((error?: Error) => void) | undefined;\n\n  disconnectCallback: (() => void) | undefined;\n\n  /**\n   * The static `open` function is used to handle `BleTransport` instantiation\n   *\n   * @param device\n   * @param writableWithResponseCharacteristic A BLE characteristic that we can write on,\n   *   and that will be acknowledged in response from the device when it receives the written value.\n   * @param writableWithoutResponseCharacteristic A BLE characteristic that we can write on,\n   *   and that will not be acknowledged in response from the device\n   * @param notifyObservable A multicast observable that emits messages received from the device\n   * @param deviceModel\n   * @param params Contains optional options and injected dependencies used by the transport implementation\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default: AsyncScheduler.\n   */\n  constructor(\n    device: Device,\n    writableWithResponseCharacteristic: Characteristic,\n    writableWithoutResponseCharacteristic: Characteristic | undefined,\n    notifyObservable: Observable<Buffer | Error>,\n    deviceModel: DeviceModel,\n    { context, rxjsScheduler }: { context?: TraceContext; rxjsScheduler?: SchedulerLike } = {},\n  ) {\n    super({ context, logType: LOG_TYPE });\n    this.id = device.deviceId;\n    this.device = device;\n    this.writableWithResponseCharacteristic = writableWithResponseCharacteristic;\n    this.writableWithoutResponseCharacteristic = writableWithoutResponseCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n    this.rxjsScheduler = rxjsScheduler;\n    this.currentTransactionIds = [];\n\n    clearDisconnectTimeout(this.id);\n\n    this.tracer.trace(`New instance of BleTransport for device ${this.id}`);\n  }\n\n  /**\n   * A message exchange (APDU request <-> response) with the device that can be aborted.\n   *\n   * The message will be BLE-encoded/framed before being sent, and the response will be BLE-decoded.\n   *\n   * @param message A buffer (u8 array) of a none BLE-encoded message (an APDU for ex) to be sent to the device\n   *   as a request\n   * @param options Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns A promise that resolves with the response data from the device.\n   */\n  exchange = (\n    message: Buffer,\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    if (this.exchangeBusyPromise) {\n      void BleTransport.disconnectDevice(this.id, this.onDisconnect);\n    }\n    const tracer = this.tracer.withUpdatedContext({\n      function: 'exchange',\n    });\n    tracer.trace('Exchanging APDU ...', { abortTimeoutMs });\n    tracer.withType('apdu').trace(`=> ${message.toString('hex')}`);\n\n    return this.exchangeAtomicImpl(() => {\n      return firstValueFrom(\n        // `sendApdu` will only emit if an error occurred, otherwise it will complete,\n        // while `receiveAPDU` will emit the full response.\n        // Consequently, it monitors the response while being able to reject on an error from the send.\n        merge(\n          this.notifyObservable.pipe((data) => receiveAPDU(data, { context: tracer.getContext() })),\n          sendAPDU(this.write, message, this.mtuSize, {\n            context: tracer.getContext(),\n          }),\n        ).pipe(\n          abortTimeoutMs ? timeout(abortTimeoutMs, this.rxjsScheduler) : tap(),\n          tap((data) => {\n            tracer.withType('apdu').trace(`<= ${data.toString('hex')}`);\n          }),\n          catchError(async (error) => {\n            // Currently only 1 reason the exchange has been explicitly aborted (other than job and transport errors): a timeout\n            if (error instanceof TimeoutError) {\n              tracer.trace(\n                'Aborting due to timeout and trying to cancel all communication write of the current exchange',\n                {\n                  abortTimeoutMs,\n                  transactionIds: this.currentTransactionIds,\n                },\n              );\n\n              // No concurrent exchange should happen at the same time, so all pending operations are part of the same exchange\n              await this.cancelPendingOperations();\n\n              throw new TransportExchangeTimeoutError('Exchange aborted due to timeout');\n            }\n\n            tracer.withType('ble-error').trace('Error while exchanging APDU', { error });\n\n            if (this.notYetDisconnected) {\n              // In such case we will always disconnect because something is bad.\n              // This sends a `disconnect` event.\n              await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n            }\n\n            const mappedError = remapError(error as IOBleErrorRemap);\n            tracer.trace('Error while exchanging APDU, mapped and throws following error', {\n              mappedError,\n            });\n            // eslint-disable-next-line @typescript-eslint/no-throw-literal\n            throw mappedError;\n          }),\n          finalize(() => {\n            tracer.trace('Clearing current transaction ids', {\n              currentTransactionIds: this.currentTransactionIds,\n            });\n            this.clearCurrentTransactionIds();\n          }),\n        ),\n      );\n    });\n  };\n\n  private async cancelPendingOperations() {\n    // BleTransport does not support cancellation\n    await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n  }\n\n  /**\n   * Sets the collection of current transaction ids to an empty array\n   */\n  private clearCurrentTransactionIds() {\n    this.currentTransactionIds = [];\n  }\n\n  /**\n   * Negotiate with the device the maximum transfer unit for the ble frames\n   * @returns Promise<number>\n   */\n  async inferMTU(): Promise<number> {\n    let mtu = (await BleClient.getMtu(this.device.deviceId));\n    this.tracer.trace('Inferring MTU ...', { currentDeviceMtu: mtu });\n\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu = await firstValueFrom(\n          merge(\n            this.notifyObservable.pipe(\n              map((maybeError) => {\n                // Catches the `PairingFailed` Error that has only been emitted\n                if (maybeError instanceof Error) {\n                  throw maybeError;\n                }\n\n                return maybeError;\n              }),\n              first((buffer) => buffer.readUInt8(0) === 0x08),\n              map((buffer) => buffer.readUInt8(5)),\n            ),\n            defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(ignoreElements()),\n          ),\n        );\n      } catch (error: any) {\n        this.tracer.withType('ble-error').trace('Error while inferring MTU', { mtu });\n\n        await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n\n        const mappedError = remapError(error);\n        this.tracer.trace('Error while inferring APDU, mapped and throws following error', {\n          mappedError,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-throw-literal\n        throw mappedError;\n      } finally {\n        // When negotiating the MTU, a message is sent/written to the device, and a transaction id was associated to this write\n        this.clearCurrentTransactionIds();\n      }\n    });\n\n    this.tracer.trace('Successfully negotiated MTU with device', {\n      mtu,\n      mtuSize: this.mtuSize,\n    });\n    if (mtu > 20) {\n      this.mtuSize = mtu;\n    }\n\n    return this.mtuSize;\n  }\n\n  /**\n   * Exposed method from the ble-plx library.\n   * Request the connection priority for the given device.\n   * @returns {Promise<void>}\n   * @param connectionPriority\n   */\n  async requestConnectionPriority(\n    connectionPriority: 'Balanced' | 'High' | 'LowPower',\n  ): Promise<void> {\n    let connectionPriorityMapped: ConnectionPriority;\n    switch (connectionPriority) {\n      case 'High':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\n        break;\n      case 'LowPower':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_LOW_POWER;\n        break;\n      case 'Balanced':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\n        break;\n    }\n    await decoratePromiseErrors(\n      BleClient.requestConnectionPriority(this.device.deviceId, connectionPriorityMapped),\n    );\n  }\n\n  /**\n   * Do not call this directly unless you know what you're doing. Communication\n   * with a Ledger device should be through the {@link exchange} method.\n   *\n   * For each call a transaction id is added to the current stack of transaction ids.\n   * With this transaction id, a pending BLE communication operations can be cancelled.\n   * Note: each frame/packet of a longer BLE-encoded message to be sent should have their unique transaction id.\n   *\n   * @param buffer BLE-encoded packet to send to the device\n   * @param frameId Frame id to make `write` aware of a bigger message that this frame/packet is part of.\n   *  Helps to create related a collection of transaction ids\n   */\n  write = async (buffer: Buffer): Promise<void> => {\n    const transactionId = uuid();\n    this.currentTransactionIds.push(transactionId);\n\n    const tracer = this.tracer.withUpdatedContext({ transactionId });\n    tracer.trace('Writing to device', {\n      willMessageBeAcked: !this.writableWithoutResponseCharacteristic,\n    });\n\n    try {\n      const uint8Array = new Uint8Array(buffer);\n      const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n      await BleClient.write(\n        this.device.deviceId,\n        currentDeviceService!,\n        this.writableWithResponseCharacteristic.uuid,\n        dataView,\n      );\n      tracer.withType('ble-frame').trace(`=> ${buffer.toString('hex')}`);\n    } catch (error: unknown) {\n      tracer.trace('Error while writing APDU', { error });\n      throw new DisconnectedDeviceDuringOperation(\n        error instanceof Error ? error.message : `${error}`,\n      );\n    }\n  };\n\n  /**\n   * We intentionally do not immediately close a transport connection.\n   * Instead, we queue the disconnect and wait for a future connection to dismiss the event.\n   * This approach prevents unnecessary disconnects and reconnects. We use the isConnected\n   * flag to ensure that we do not trigger a disconnect if the current cached transport has\n   * already been disconnected.\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    const tracer = this.tracer.withUpdatedContext({ function: 'close' });\n    tracer.trace('Closing, queuing a disconnect with a timeout ...');\n\n    let resolve: (value: void | PromiseLike<void>) => void;\n    const disconnectPromise = new Promise<void>((innerResolve) => {\n      resolve = innerResolve;\n    });\n\n    clearDisconnectTimeout(this.id);\n\n    this.disconnectTimeout = setTimeout(() => {\n      tracer.trace('Disconnect timeout has been reached ...');\n      if (this.isConnected) {\n        BleTransport.disconnectDevice(this.id, this.onDisconnect, tracer.getContext())\n          .catch(() => {})\n          .finally(resolve);\n      } else {\n        resolve();\n      }\n    }, BleTransport.disconnectTimeoutMs);\n\n    // The closure will occur no later than 5s, triggered either by disconnection\n    // or the actual response of the apdu.\n    await Promise.race([this.exchangeBusyPromise || Promise.resolve(), disconnectPromise]);\n  }\n}\n\n/**\n * Opens a BLE connection with a given device. Returns a Transport instance.\n *\n * @param deviceOrId\n * @param needsReconnect\n * @param timeoutMs Optional Timeout (in ms) applied during the connection with the device\n * @param context Optional tracing/log context\n * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\n *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\n * @returns A BleTransport instance\n */\nasync function open(\n  deviceOrId: Device | string,\n  needsReconnect: boolean,\n  timeoutMs?: number,\n  context?: TraceContext,\n  { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\n) {\n  const tracer = new LocalTracer(LOG_TYPE, context);\n  let device: Device;\n  tracer.trace(`Opening ${deviceOrId}`, { needsReconnect });\n  let deviceId: string;\n  let transport: BleTransport;\n\n  if (typeof deviceOrId === 'string') {\n    deviceId = deviceOrId;\n    if (transportsCache[deviceOrId]) {\n      tracer.trace('Transport in cache, using it');\n      clearDisconnectTimeout(deviceOrId);\n\n      // The cached transport probably has an older trace/log context\n      transportsCache[deviceOrId].setTraceContext(context);\n      return transportsCache[deviceOrId];\n    }\n\n    tracer.trace(`Trying to open device: ${deviceOrId}`);\n    await awaitsBleOn();\n\n    // Returns a list of known devices by their identifiers\n    const devices = (await BleClient.getDevices([deviceOrId]));\n    tracer.trace(`Found ${devices.length} already known device(s) with given id`, { deviceOrId });\n    [device] = devices;\n\n    if (!device) {\n      // Returns a list of the peripherals currently connected to the system\n      // which have discovered services, connected to system doesn't mean\n      // connected to our app, we check that below.\n      const services = (await BleClient.getServices(deviceOrId)).map((it) => it.uuid);\n      const connectedDevices = (await BleClient.getConnectedDevices(services));\n      const connectedDevicesFiltered = connectedDevices.filter((d) => d.deviceId === deviceOrId);\n      tracer.trace(\n        `No known device with given id.\n        Found ${connectedDevicesFiltered.length} devices from already connected devices`,\n        { deviceOrId },\n      );\n      [device] = connectedDevicesFiltered;\n    }\n\n    if (!device) {\n      // We still don't have a device, so we attempt to connect to it.\n      tracer.trace('No known nor connected devices with given id. Trying to connect to device', {\n        deviceOrId,\n        timeoutMs,\n      });\n\n      // Nb ConnectionOptions dropped since it's not used internally by ble-plx.\n      try {\n        await BleClient.connect(deviceOrId, () => {\n          transport.onDisconnect?.();\n        }, {\n          timeout: timeoutMs,\n        });\n      } catch (e: any) {\n        tracer.trace(`Error code: ${e.errorCode}`);\n        throw e;\n      }\n    }\n\n    if (!device) {\n      throw new CantOpenDevice();\n    }\n  } else {\n    // It was already a Device\n    device = deviceOrId;\n    deviceId = deviceOrId.deviceId;\n  }\n\n  const connectedDevices = await BleClient.getConnectedDevices(getBluetoothServiceUuids());\n\n  if (!connectedDevices.find((it) => it.deviceId === deviceId)) {\n    tracer.trace('Device found but not connected. connecting...', { timeoutMs, connectOptions });\n    try {\n      await BleClient.connect(deviceId, () => {\n        transport.onDisconnect?.();\n      }, {\n        timeout: timeoutMs,\n      });\n    } catch (error: any) {\n      tracer.trace('Connect error', { error });\n      // eslint-disable-next-line @typescript-eslint/no-throw-literal\n      throw remapError(error);\n    }\n  }\n\n  tracer.trace('Device is connected now, getting services and characteristics');\n\n  let services: BleService[] = [];\n\n  await BleClient.discoverServices(deviceId);\n  services = (await BleClient.getServices(deviceId));\n\n  let res: BluetoothInfos | undefined = retrieveInfos(device);\n  const characteristics: BleCharacteristic[] = [];\n\n  if (!res) {\n    for (const serviceUUID of getBluetoothServiceUuids()) {\n      try {\n        const deviceService = services.find((it) => it.uuid === serviceUUID);\n        res = getInfosForServiceUuid(serviceUUID);\n        if (res && deviceService) {\n          characteristics.push(...deviceService.characteristics);\n          currentDeviceService = res.serviceUuid;\n          break;\n        }\n      } catch (e) {\n        // Attempt to connect to the next service\n      }\n    }\n  }\n\n  if (!res) {\n    tracer.trace('Service not found');\n    throw new TransportError('service not found', 'BLEServiceNotFound');\n  }\n\n  const {\n    deviceModel, writeUuid, writeCmdUuid, notifyUuid,\n  } = res;\n\n  /* if (!characteristics) {\n    characteristics = await device.characteristicsForService(serviceUuid);\n  } */\n\n  if (!characteristics) {\n    tracer.trace('Characteristics not found');\n    throw new TransportError('service not found', 'BLEServiceNotFound');\n  }\n\n  let writableWithResponseCharacteristic: Characteristic | null | undefined;\n  let writableWithoutResponseCharacteristic: Characteristic | undefined;\n  // A characteristic that can monitor value changes\n  let notifiableCharacteristic: Characteristic | null | undefined;\n\n  for (const c of characteristics) {\n    if (c.uuid === writeUuid) {\n      writableWithResponseCharacteristic = c;\n    } else if (c.uuid === writeCmdUuid) {\n      writableWithoutResponseCharacteristic = c;\n    } else if (c.uuid === notifyUuid) {\n      notifiableCharacteristic = c;\n    }\n  }\n\n  if (!writableWithResponseCharacteristic) {\n    throw new TransportError('write characteristic not found', 'BLECharacteristicNotFound');\n  }\n\n  if (!notifiableCharacteristic) {\n    throw new TransportError('notify characteristic not found', 'BLECharacteristicNotFound');\n  }\n\n  if (!writableWithResponseCharacteristic.properties.write) {\n    throw new TransportError(\n      'The writable-with-response characteristic is not writable with response',\n      'BLECharacteristicInvalid',\n    );\n  }\n\n  if (!notifiableCharacteristic.properties.notify) {\n    throw new TransportError('notify characteristic not notifiable', 'BLECharacteristicInvalid');\n  }\n\n  if (writableWithoutResponseCharacteristic) {\n    if (!writableWithoutResponseCharacteristic.properties.writeWithoutResponse) {\n      throw new TransportError(\n        'The writable-without-response characteristic is not writable without response',\n        'BLECharacteristicInvalid',\n      );\n    }\n  }\n\n  const deviceMtu = await BleClient.getMtu(device.deviceId);\n  tracer.trace(`device.mtu=${deviceMtu}`);\n\n  // Inits the observable that will emit received data from the device via BLE\n  const notifyObservable = monitorCharacteristic(deviceId,\n    currentDeviceService!,\n    notifiableCharacteristic,\n    context).pipe(\n    catchError((e) => {\n      // LL-9033 fw 2.0.2 introduced this case, we silence the inner unhandled error.\n      // It will be handled when negotiating the MTU in `inferMTU` but will be ignored in other cases.\n      const msg = String(e);\n      return msg.includes('notify change failed')\n        ? of(new PairingFailed(msg))\n        : throwError(() => e);\n    }),\n    tap((value) => {\n      if (value instanceof PairingFailed) return;\n      trace({ type: 'ble-frame', message: `<= ${value.toString('hex')}`, context });\n    }),\n    // Returns a new Observable that multicasts (shares) the original Observable.\n    // As long as there is at least one Subscriber this Observable will be subscribed and emitting data.\n    share(),\n  );\n\n  // Keeps the input from the device observable alive (multicast observable)\n  const notif = notifyObservable.subscribe();\n\n  transport = new BleTransport(\n    device,\n    writableWithResponseCharacteristic,\n    writableWithoutResponseCharacteristic,\n    notifyObservable,\n    deviceModel,\n    {\n      context,\n      rxjsScheduler,\n    },\n  );\n  tracer.trace('New BleTransport created');\n\n  // Keeping it as a comment for now but if no new bluetooth issues occur, we will be able to remove it\n  // await transport.requestConnectionPriority(\"High\");\n\n  // eslint-disable-next-line prefer-const\n  // let disconnectedSub: Subscription;\n\n  // Callbacks on `react-native-ble-plx` notifying the device has been disconnected\n  transport.onDisconnect = (error?: Error) => {\n    transport.isConnected = false;\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    // disconnectedSub?.remove();\n\n    clearDisconnectTimeout(transport.id);\n    delete transportsCache[transport.id];\n    tracer.trace(\n      `On device disconnected callback: cleared cached transport for ${transport.id},\n      emitting Transport event \"disconnect. Error: ${error}\"`,\n      { reason: error },\n    );\n    transport.emit('disconnect', error);\n    transport.disconnectCallback?.();\n  };\n\n  // eslint-disable-next-line require-atomic-updates\n  transportsCache[transport.id] = transport;\n  const beforeMTUTime = Date.now();\n\n  /* disconnectedSub = device.onDisconnected((e) => {\n    if (!transport.notYetDisconnected) return;\n    onDisconnect(e);\n  }); */\n\n  try {\n    await transport.inferMTU();\n  } finally {\n    const afterMTUTime = Date.now();\n\n    if (reconnectionConfig) {\n      // Refer to ledgerjs archived repo issue #279.\n      // All HW .v1 LNX have a bug that prevents us from communicating with the device right after pairing.\n      // When we connect for the first time we issue a disconnect and reconnect, this guarantees that we are\n      // in a good state. This is avoidable in some key scenarios ↓\n      if (afterMTUTime - beforeMTUTime < reconnectionConfig.pairingThreshold) {\n        needsReconnect = false;\n      } else if (deviceModel.id === DeviceModelId.stax) {\n        tracer.trace('Skipping \"needsReconnect\" strategy for Stax');\n        needsReconnect = false;\n      }\n\n      if (needsReconnect) {\n        tracer.trace('Device needs reconnection. Triggering a disconnect');\n        await BleTransport.disconnectDevice(transport.id, transport.onDisconnect);\n        await delay(reconnectionConfig.delayAfterFirstPairing);\n      }\n    } else {\n      needsReconnect = false;\n    }\n  }\n\n  if (needsReconnect) {\n    tracer.trace('Reconnecting');\n    return open(device, false, timeoutMs, context);\n  }\n\n  return transport;\n}\n","import { BleClient } from '@capacitor-community/bluetooth-le';\nimport type { Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\nimport { v4 as uuid } from 'uuid';\nimport type { BleDevice } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\n\nimport { IS_CAPACITOR } from '../../config';\nimport BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\n\ninterface ScannedDevice {\n  identifier: string;\n  device: BleDevice;\n}\n\nexport interface LedgerConnection {\n  device: BleDevice;\n  bleTransport: BleTransport;\n}\n\nlet listeningSubscription: TransportSubscription | undefined;\n\nlet scannedDevices: ScannedDevice[] = [];\nlet pairedDevice: LedgerConnection | undefined;\nlet onLedgerConnected: ((connection: LedgerConnection) => void) | undefined;\n\nfunction isConnecting() {\n  return !!listeningSubscription;\n}\n\nfunction scannedDeviceIsValidYet(scannedDevice: ScannedDevice): boolean {\n  if (!scannedDevices.find((it) => it.identifier === scannedDevice.identifier)) {\n    // List is already cleared\n    return false;\n  }\n\n  // A device is already paired\n  return !pairedDevice;\n}\n\nasync function tryConnectingLedgerDevice(scannedDevice: ScannedDevice) {\n  try {\n    // Check if stopped before retry\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\n\n    const bleTransport = await BleTransport.open(scannedDevice.device);\n    // Check if stopped before connection establish\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\n\n    const ledgerConnection = {\n      device: scannedDevice.device,\n      bleTransport,\n    };\n    pairedDevice = ledgerConnection;\n\n    bleTransport.disconnectCallback = () => {\n      pairedDevice = undefined;\n      if (isConnecting()) {\n        stop();\n        start();\n      }\n    };\n\n    setTimeout(() => {\n      // Make sure not disconnected yet\n      if (pairedDevice?.device.deviceId === ledgerConnection.device.deviceId) {\n        onLedgerConnected?.(ledgerConnection);\n        stop();\n      } else if (isConnecting()) {\n        // Unexpectedly, disconnected before calling the callback, restart!\n        pairedDevice = undefined;\n        stop();\n        void start();\n      }\n    }, 1000);\n  } catch (error) {\n    setTimeout(() => {\n      void tryConnectingLedgerDevice(scannedDevice);\n    }, 10000);\n  }\n}\n\nasync function isSupported() {\n  if (!IS_CAPACITOR) return false;\n\n  try {\n    await BleClient.initialize({\n      androidNeverForLocation: true,\n    });\n    await BleClient.requestEnable();\n  } catch (error) { /* empty */ }\n\n  return BleClient.isEnabled();\n}\n\nfunction start() {\n  listeningSubscription = BleTransport.listen({\n    next: (event: { type: string; device?: BleDevice }) => {\n      switch (event.type) {\n        case 'add':\n          if (event.device) {\n            if (!event.device.name) return;\n            if (scannedDevices.find((it) => it.device.deviceId === event.device?.deviceId)) return;\n            const scannedDevice = { identifier: uuid(), device: event.device };\n            scannedDevices.push(scannedDevice);\n            void tryConnectingLedgerDevice(scannedDevice);\n          }\n          break;\n      }\n    },\n    error: () => {\n      stop();\n    },\n    complete: () => {\n      stop();\n    },\n  });\n}\n\nfunction stop() {\n  scannedDevices = [];\n  listeningSubscription?.unsubscribe();\n  listeningSubscription = undefined;\n}\n\nfunction connect(): Promise<LedgerConnection> {\n  return new Promise((resolve) => {\n    onLedgerConnected = resolve;\n    if (pairedDevice) {\n      onLedgerConnected(pairedDevice);\n      return;\n    }\n\n    if (isConnecting()) return;\n    start();\n  });\n}\n\nexport const BleConnector = {\n  isSupported,\n  connect,\n  stop,\n};\n","import { BluetoothLe } from '@capacitor-community/bluetooth-le';\nimport { BluetoothRequired } from '@ledgerhq/errors';\n\nexport async function awaitsBleOn(): Promise<void> {\n  await BluetoothLe.initialize();\n  const isEnabled = await BluetoothLe.isEnabled();\n  if (!isEnabled) {\n    throw new BluetoothRequired('', {\n      state: 'disable',\n    });\n  }\n}\n"],"names":["remapError","error","message","includes","DisconnectedDevice","rethrowError","e","Error","LOG_TYPE","reconnectionConfig","pairingThreshold","delayAfterFirstPairing","bluetoothInfoCache","transportsCache","connectOptions","requestMTU","connectionPriority","clearDisconnectTimeout","deviceId","context","cachedTransport","disconnectTimeout","trace","type","clearTimeout","currentDeviceService","listeningSubscription","BleTransport","Transport","listen","observer","unsubscribed","LocalTracer","BleClient","getConnectedDevices","getBluetoothServiceUuids","then","async","it","devices","next","device","stopLEScan","requestLEScan","services","result","unsubscribe","open","deviceOrId","timeoutMs","rxjsScheduler","arguments","length","undefined","constructor","writableWithResponseCharacteristic","writableWithoutResponseCharacteristic","notifyObservable","deviceModel","_this","super","logType","this","_defineProperty","abortTimeoutMs","exchangeBusyPromise","disconnectDevice","id","onDisconnect","tracer","withUpdatedContext","function","withType","toString","exchangeAtomicImpl","firstValueFrom","merge","pipe","data","receiveAPDU","getContext","sendAPDU","write","mtuSize","timeout","tap","catchError","TimeoutError","transactionIds","currentTransactionIds","cancelPendingOperations","TransportExchangeTimeoutError","notYetDisconnected","mappedError","finalize","clearCurrentTransactionIds","transactionId","uuid","push","willMessageBeAcked","uint8Array","Uint8Array","buffer","dataView","DataView","byteOffset","byteLength","DisconnectedDeviceDuringOperation","inferMTU","mtu","getMtu","currentDeviceMtu","map","maybeError","first","readUInt8","defer","from","Buffer","ignoreElements","requestConnectionPriority","connectionPriorityMapped","ConnectionPriority","CONNECTION_PRIORITY_BALANCED","CONNECTION_PRIORITY_LOW_POWER","promise","catch","close","resolve","disconnectPromise","Promise","innerResolve","setTimeout","isConnected","finally","disconnectTimeoutMs","race","needsReconnect","transport","setTraceContext","BluetoothLe","initialize","isEnabled","BluetoothRequired","state","awaitsBleOn","getDevices","getServices","connectedDevicesFiltered","filter","d","connect","_transport$onDisconne","_transport","call","errorCode","CantOpenDevice","find","_transport$onDisconne2","_transport2","discoverServices","res","uuids","serviceUUID","infos","getInfosForServiceUuid","retrieveInfos","characteristics","deviceService","serviceUuid","TransportError","writeUuid","writeCmdUuid","notifyUuid","notifiableCharacteristic","c","properties","notify","writeWithoutResponse","deviceMtu","monitorCharacteristic","serviceId","characteristic","Observable","o","characteristicUuid","startNotifications","value","stopEnabledNotifications","msg","String","of","PairingFailed","throwError","share","notif","subscribe","_transport$disconnect","_transport3","reason","emit","disconnectCallback","beforeMTUTime","Date","now","afterMTUTime","DeviceModelId","stax","ms","success","disconnect","pairedDevice","onLedgerConnected","scannedDevices","isConnecting","scannedDeviceIsValidYet","scannedDevice","identifier","tryConnectingLedgerDevice","bleTransport","ledgerConnection","stop","start","_pairedDevice","_onLedgerConnected","event","name","_event$device","complete","_listeningSubscriptio","BleConnector","isSupported","IS_CAPACITOR","androidNeverForLocation","requestEnable"],"sourceRoot":""}